---
title: Timing Out
description: Learn how to set time constraints on operations with `Effect.timeout`. Discover how to handle scenarios where tasks need to complete within a specified timeframe. Explore variations like `timeoutTo`, `timeoutFail`, and `timeoutFailCause` to customize behavior when a timeout occurs, providing more control and flexibility in managing time-sensitive operations.
sidebar:
  order: 6
---

import { Aside } from "@astrojs/starlight/components"

In the world of programming, we often deal with tasks that take some time to complete.
Sometimes, we want to set a limit on how long we are willing to wait for a task to finish.
This is where the `Effect.timeout` function comes into play.
It allows us to put a time constraint on an operation, ensuring that it doesn't run indefinitely.

## Basic Usage

### timeout

The `Effect.timeout` function employs a [Duration](/data-types/duration) parameter to establish a time limit on an operation. If the operation exceeds this limit, a `TimeoutException` is triggered, indicating a timeout has occurred.

**Example**

```ts twoslash file=<rootDir>/timeout/timeout.ts

```

In the above example, the operation completes within the specified duration, so the result is returned successfully.

If the operation takes longer than the specified duration, a `TimeoutException` is raised:

```ts collapse={3-8} file=<rootDir>/timeout/timeout-expired.ts

```

### timeoutOption

If you want to handle the timeout as a regular result, you can use `Effect.timeoutOption` instead of `Effect.timeout`.

**Example**

```ts twoslash file=<rootDir>/timeout/timeoutOption.ts

```

In this example, the first effect completes within the specified duration, while the second effect times out.
The result of the timed-out effect is wrapped in an [Option](/data-types/option) type, allowing you to handle the timeout as a regular result.

## Handling Timeouts

When an operation does not finish within the specified duration, the behavior of the `Effect.timeout` depends on whether the operation is uninterruptible.

<Aside type="note" title="Uninterruptible Effects">
  An uninterruptible effect is one that, once started, cannot be stopped
  mid-execution by the timeout mechanism directly. This could be because the
  operations within the effect need to run to completion to avoid leaving
  the system in an inconsistent state.
</Aside>

1. **Interruptible Operation**: If the operation can be interrupted, it is terminated immediately once the timeout threshold is reached, resulting in a `TimeoutException`.

   ```ts twoslash file=<rootDir>/timeout/interruptible.ts

   ```

2. **Uninterruptible Operation**: If the operation is uninterruptible, it continues until completion before the `TimeoutException` is assessed.

   ```ts twoslash file=<rootDir>/timeout/uninterruptible.ts

   ```

## Disconnection on Timeout

The `Effect.disconnect` function is used to handle timeouts in a nuanced way, particularly when dealing with uninterruptible effects.

It allows the uninterruptible effect to complete its operations in the background, while the main control flow proceeds as if a timeout had occurred.

Here's the distinction:

**Without** `Effect.disconnect`:

- An uninterruptible effect will ignore the timeout and continue executing until it completes, after which the timeout error is assessed.
- This can lead to delays in recognizing a timeout condition because the system must wait for the effect to complete.

**With** `Effect.disconnect`:

- The uninterruptible effect is allowed to continue in the background, independent of the main control flow.
- The main control flow recognizes the timeout immediately and proceeds with the timeout error or alternative logic, without having to wait for the effect to complete.
- This method is particularly useful when the operations of the effect do not need to block the continuation of the program, despite being marked as uninterruptible.

**Example**

Consider a scenario where a long-running data processing task is initiated, and you want to ensure the system remains responsive, even if the data processing takes too long:

```ts twoslash file=<rootDir>/timeout/disconnect.ts

```

## Customizing Timeout Behavior

In addition to the basic `Effect.timeout` function, there are variations available that allow you to customize the behavior when a timeout occurs.

### timeoutFail

The `Effect.timeoutFail` function allows you to produce a specific error when a timeout happens:

```ts twoslash file=<rootDir>/timeout/timeoutFail.ts

```

### timeoutFailCause

The `Effect.timeoutFailCause` function allows you to produce a specific defect when a timeout occurs.
This is useful when you need to handle timeouts as exceptional cases in your code:

```ts twoslash file=<rootDir>/timeout/timeoutFailCause.ts

```

### timeoutTo

The `Effect.timeoutTo` function is similar to `Effect.timeout`, but it provides more control over the final result type.
It allows you to define alternative outcomes for both successful and timed-out operations:

```ts twoslash file=<rootDir>/timeout/timeoutTo.ts

```
