---
title: Advanced Usage
description: Advanced Usage
sidebar:
  order: 5
---

import { Aside } from "@astrojs/starlight/components"

## Declaring New Data Types

Creating schemas for new data types is crucial to defining the expected structure of information in your application. This guide explores how to declare schemas for new data types. We'll cover two important concepts: declaring schemas for primitive data types and type constructors.

### Declaring Schemas for Primitive Data Types

A primitive data type represents simple values. To declare a schema for a primitive data type, like the `File` type in TypeScript, we use the `S.declare` constructor along with a type guard. Let's go through an example:

```ts twoslash
import { Schema } from "@effect/schema"

const FileFromSelf = Schema.declare(
  (input: unknown): input is File => input instanceof File
)

const decode = Schema.decodeUnknownSync(FileFromSelf)

console.log(decode(new File([], "")))
// Output: File { size: 0, type: '', name: '', lastModified: 1724774163056 }

decode(null)
/*
throws
ParseError: Expected <declaration schema>, actual null
*/
```

As you can see, the error message describes what went wrong but doesn't provide much information about which schema caused the error (`"Expected <declaration schema>"`). To enhance the default error message, you can add annotations, particularly the `identifier`, `title`, and `description` annotations (none of these annotations are required, but they are encouraged for good practice and can make your schema "self-documenting"). These annotations will be utilized by the messaging system to return more meaningful messages.

A "title" should be concise, while a "description" provides a more detailed explanation of the purpose of the data described by the schema.

```ts twoslash
import { Schema } from "@effect/schema"

const FileFromSelf = Schema.declare(
  (input: unknown): input is File => input instanceof File,
  {
    identifier: "FileFromSelf",
    description: "The `File` type in JavaScript"
  }
)

const decode = Schema.decodeUnknownSync(FileFromSelf)

console.log(decode(new File([], "")))
// Output: File { size: 0, type: '', name: '', lastModified: 1724774221857 }

decode(null)
/*
throws
ParseError: Expected FileFromSelf, actual null
*/
```

### Declaring Schemas for Type Constructors

Type constructors are generic types that take one or more types as arguments and return a new type. If you need to define a schema for a type constructor, you can use the `S.declare` constructor. Let's illustrate this with a schema for `ReadonlySet<A>`:

```ts twoslash
import { ParseResult, Schema } from "@effect/schema"

export const MyReadonlySet = <A, I, R>(
  // Schema for the elements of the Set
  item: Schema.Schema<A, I, R>
): Schema.Schema<ReadonlySet<A>, ReadonlySet<I>, R> =>
  Schema.declare(
    // Store the schema for the elements
    [item],
    {
      // Decoding function
      decode: (item) => (input, parseOptions, ast) => {
        if (input instanceof Set) {
          // Decode the elements
          const elements = ParseResult.decodeUnknown(Schema.Array(item))(
            Array.from(input.values()),
            parseOptions
          )
          // Return a Set containing the parsed elements
          return ParseResult.map(
            elements,
            (as): ReadonlySet<A> => new Set(as)
          )
        }
        return ParseResult.fail(new ParseResult.Type(ast, input))
      },
      // Encoding function
      encode: (item) => (input, parseOptions, ast) => {
        if (input instanceof Set) {
          // Encode the elements
          const elements = ParseResult.encodeUnknown(Schema.Array(item))(
            Array.from(input.values()),
            parseOptions
          )
          // Return a Set containing the parsed elements
          return ParseResult.map(
            elements,
            (is): ReadonlySet<I> => new Set(is)
          )
        }
        return ParseResult.fail(new ParseResult.Type(ast, input))
      }
    },
    {
      description: `ReadonlySet<${Schema.format(item)}>`
    }
  )

// const setOfNumbers: S.Schema<ReadonlySet<string>, ReadonlySet<number>>
const setOfNumbers = MyReadonlySet(Schema.NumberFromString)

const decode = Schema.decodeUnknownSync(setOfNumbers)

console.log(decode(new Set(["1", "2", "3"]))) // Set(3) { 1, 2, 3 }

decode(null)
/*
throws
ParseError: Expected ReadonlySet<NumberFromString>, actual null
*/

decode(new Set(["1", null, "3"]))
/*
throws
ParseError: ReadonlyArray<NumberFromString>
└─ [1]
   └─ NumberFromString
      └─ Encoded side transformation failure
         └─ Expected string, actual null
*/
```

<Aside type="caution" title="Decoding/Encoding Limitations">
  The decoding and encoding functions cannot use context (the `R` type
  parameter) and cannot use async effects.
</Aside>

### Adding Annotations

When you define a new data type, some compilers like `Arbitrary` or `Pretty` may not know how to handle the newly defined data. For instance:

```ts twoslash
import { Arbitrary, Schema } from "@effect/schema"

const FileFromSelf = Schema.declare(
  (input: unknown): input is File => input instanceof File,
  {
    identifier: "FileFromSelf"
  }
)

// Create an Arbitrary instance for FileFromSelf schema
const arb = Arbitrary.make(FileFromSelf)
/*
throws:
Error: Missing annotation
details: Generating an Arbitrary for this schema requires an "arbitrary" annotation
schema (Declaration): FileFromSelf
*/
```

In such cases, you need to provide annotations to ensure proper functionality:

```ts twoslash
import { Arbitrary, FastCheck, Pretty, Schema } from "@effect/schema"

const FileFromSelf = Schema.declare(
  (input: unknown): input is File => input instanceof File,
  {
    identifier: "FileFromSelf",
    // Provide an arbitrary function to generate random File instances
    arbitrary: () => (fc) =>
      fc
        .tuple(fc.string(), fc.string())
        .map(([content, path]) => new File([content], path)),
    // Provide a pretty function to generate human-readable representation of File instances
    pretty: () => (file) => `File(${file.name})`
  }
)

// Create an Arbitrary instance for FileFromSelf schema
const arb = Arbitrary.make(FileFromSelf)

// Generate sample files using the Arbitrary instance
const files = FastCheck.sample(arb, 2)
console.log(files)
/*
Example Output:
[
  File { size: 5, type: '', name: 'C', lastModified: 1706435571176 },
  File { size: 1, type: '', name: '98Ggmc', lastModified: 1706435571176 }
]
*/

// Create a Pretty instance for FileFromSelf schema
const pretty = Pretty.make(FileFromSelf)

// Print human-readable representation of a file
console.log(pretty(files[0]))
// Example Output: "File(C)"
```

## Branded types

TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.
This can cause issues when types that are semantically different are treated as if they were the same.

```ts twoslash
type UserId = string
type Username = string

declare const getUser: (id: UserId) => object

const myUsername: Username = "gcanti"

getUser(myUsername) // This erroneously works
```

In the above example, `UserId` and `Username` are both aliases for the same type, `string`. This means that the `getUser` function can mistakenly accept a `Username` as a valid `UserId`, causing bugs and errors.

To avoid these kinds of issues, the Effect ecosystem provides a way to create custom types with a unique identifier attached to them. These are known as **branded types**.

```ts twoslash
import { Brand } from "effect"

type UserId = string & Brand.Brand<"UserId">
type Username = string

declare const getUser: (id: UserId) => object

const myUsername: Username = "gcanti"

// @ts-expect-error
getUser(myUsername)
/*
Argument of type 'string' is not assignable to parameter of type 'UserId'.
  Type 'string' is not assignable to type 'Brand<"UserId">'.ts(2345)
*/
```

By defining `UserId` as a branded type, the `getUser` function can accept only values of type `UserId`, and not plain strings or other types that are compatible with strings. This helps to prevent bugs caused by accidentally passing the wrong type of value to the function.

There are two ways to define a schema for a branded type, depending on whether you:

- want to define the schema from scratch
- have already defined a [branded type](/docs/code-style/branded-types) via `effect/Brand` and want to reuse it to define a schema

### Defining a brand schema from scratch

To define a schema for a branded type from scratch, you can use the `Schema.brand` function.

```ts twoslash
import { Schema } from "@effect/schema"

const UserId = Schema.String.pipe(Schema.brand("UserId"))

// string & Brand<"UserId">
type UserId = Schema.Schema.Type<typeof UserId>
```

Note that you can use `unique symbol`s as brands to ensure uniqueness across modules / packages:

```ts twoslash
import { Schema } from "@effect/schema"

const UserIdBrand = Symbol.for("UserId")

const UserId = Schema.String.pipe(Schema.brand(UserIdBrand))

// string & Brand<typeof UserIdBrand>
type UserId = Schema.Schema.Type<typeof UserId>
```

### Reusing an existing branded constructor

If you have already defined a [branded type](/docs/code-style/branded-types) using the `effect/Brand` module, you can reuse it to define a schema using the `fromBrand` combinator exported by the `@effect/docs/schema/Schema` module.

```ts twoslash
import { Schema } from "@effect/schema"
import { Brand } from "effect"

// the existing branded type
type UserId = string & Brand.Brand<"UserId">

const UserId = Brand.nominal<UserId>()

// Define a schema for the branded type
const UserIdSchema = Schema.String.pipe(Schema.fromBrand(UserId))
```

### Utilizing Default Constructors

The `Schema.brand` function includes a default constructor to facilitate the creation of branded values.

```ts twoslash
import { Schema } from "@effect/schema"

const UserId = Schema.String.pipe(Schema.brand("UserId"))

const userId = UserId.make("123") // Creates a branded UserId
```

## Property Signatures

### Basic Usage of Property Signatures

A `PropertySignature` generally represents a transformation from a "From" field:

```ts
{
  fromKey: fromType
}
```

to a "To" field:

```ts
{
  toKey: toType
}
```

Let's start with the simple definition of a property signature that can be used to add annotations:

```ts twoslash
import { Schema } from "@effect/schema"

/*
Schema.Struct<{
    name: typeof Schema.String;
    age: Schema.propertySignature<typeof Schema.NumberFromString>;
}>
*/
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).annotations({
    title: "Age"
  })
})
```

Let's delve into the details of all the information contained in the type of a `PropertySignature`:

```ts
age: PropertySignature<
  ToToken,
  ToType,
  FromKey,
  FromToken,
  FromType,
  HasDefault,
  Context
>
```

| Param Name   | Description                                                                                                         |
| ------------ | ------------------------------------------------------------------------------------------------------------------- |
| `age`        | Key of the "To" field                                                                                               |
| `ToToken`    | Indicates field requirement: `"?:"` for optional, `":"` for required                                                |
| `ToType`     | Type of the "To" field                                                                                              |
| `FromKey`    | (Optional, default = `never`) Indicates the source field key, typically the same as "To" field key unless specified |
| `FormToken`  | Indicates source field requirement: `"?:"` for optional, `":"` for required                                         |
| `FromType`   | Type of the "From" field                                                                                            |
| `HasDefault` | Indicates if there is a constructor default value (Boolean)                                                         |

In our case, the type

```ts
PropertySignature<":", number, never, ":", string, false, never>
```

indicates that there is the following transformation:

| Param Name   | Description                                                                |
| ------------ | -------------------------------------------------------------------------- |
| `age`        | Key of the "To" field                                                      |
| `ToToken`    | `":"` indicates that the `age` field is required                           |
| `ToType`     | Type of the `age` field is `number`                                        |
| `FromKey`    | `never` indicates that the decoding occurs from the same field named `age` |
| `FormToken`  | `":"` indicates that the decoding occurs from a required `age` field       |
| `FromType`   | Type of the "From" field is `string`                                       |
| `HasDefault` | `false`: indicates there is no default value                               |

Now, suppose the field from which decoding occurs is named `"AGE"`, but for our model, we want to keep the name in lowercase `"age"`. To achieve this result, we need to map the field key from `"AGE"` to `"age"`, and to do that, we can use the `fromKey` combinator:

```ts twoslash
import { Schema } from "@effect/schema"

/*
Schema.Struct<{
    name: typeof Schema.String;
    age: Schema.PropertySignature<":", number, "AGE", ":", string, false, never>;
}>
*/
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).pipe(
    Schema.fromKey("AGE")
  )
})
```

This modification is represented in the type of the created `PropertySignature`:

```ts
// fromKey ----------------------v
PropertySignature<":", number, "AGE", ":", string, false, never>
```

Now, let's see an example of decoding:

```ts twoslash
import { Schema } from "@effect/schema"

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).pipe(
    Schema.fromKey("AGE")
  )
})

console.log(Schema.decodeUnknownSync(Person)({ name: "name", AGE: "18" }))
// Output: { name: 'name', age: 18 }
```

### Optional Fields

**Basic Optional Property**

`Schema.optional(schema: Schema<A, I, R>)` defines a basic optional property that handles different inputs and outputs during decoding and encoding:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - Input `a: A` transforms back to `i: I`

**Optional with Nullability**

`Schema.optionalWith(schema: Schema<A, I, R>, { nullable: true })` allows handling of `null` values as equivalent to missing values:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - `null` transforms to `<missing value>`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - `undefined` remains `undefined`
  - Input `a: A` transforms back to `i: I`

**Optional with Exactness**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true })` ensures that only the exact types specified are handled, excluding `undefined`:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - Input `a: A` transforms back to `i: I`

**Combining Nullability and Exactness**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true, nullable: true })` combines handling for exact types and null values:

- **Decoding:**
  - `<missing value>` remains `<missing value>`
  - `null` transforms to `<missing value>`
  - Input `i: I` transforms to `a: A`
- **Encoding:**
  - `<missing value>` remains `<missing value>`
  - Input `a: A` transforms back to `i: I`

### Representing Optional Fields with never Type

When defining types in TypeScript that include optional fields with the type `never`, such as:

```ts
type MyType = {
  readonly foo?: never
}
```

the approach varies based on the `exactOptionalPropertyTypes` configuration in your `tsconfig.json`

**TypeScript Configuration: `exactOptionalPropertyTypes = false`**

When this feature is turned off, you can employ the `Schema.optional` function. This approach allows the field to implicitly accept `undefined` as a value.

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  foo: Schema.optional(Schema.Never)
})
```

**TypeScript Configuration: `exactOptionalPropertyTypes = true`**

When this feature is turned on, the `Schema.optionalWith` function is recommended.
It ensures stricter enforcement of the field's absence.

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  foo: Schema.optionalWith(Schema.Never, { exact: true })
})
```

### Default Values

The `default` option in schemas allows you to set default values that are applied during both decoding and object construction phases. This feature ensures that even if certain properties are not provided by the user, the system will automatically use the specified default values.

**Example**

Let's see how default values work in both the decoding and constructing phases, illustrating how the default value is applied when certain properties are not provided.

```ts twoslash
import { Schema } from "@effect/schema"

const Product = Schema.Struct({
  name: Schema.String,
  price: Schema.NumberFromString,
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () => 1
  })
})

// Applying defaults in the decoding phase

console.log(
  Schema.decodeUnknownSync(Product)({ name: "Laptop", price: "999" })
)
// Output: { name: 'Laptop', price: 999, quantity: 1 }

console.log(
  Schema.decodeUnknownSync(Product)({
    name: "Laptop",
    price: "999",
    quantity: "2"
  })
)
// Output: { name: 'Laptop', price: 999, quantity: 2 }

// Applying defaults in the constructor

console.log(Product.make({ name: "Laptop", price: 999 }))
// Output: { name: 'Laptop', price: 999, quantity: 1 }

console.log(Product.make({ name: "Laptop", price: 999, quantity: 2 }))
// Output: { name: 'Laptop', price: 999, quantity: 2 }
```

`Schema.optionalWith` can be configured with additional options to handle decoding and encoding precisely:

**Basic Optional with Default**

`Schema.optionalWith(schema: Schema<A, I, R>, { default: () => A })`

- **Decoding:** Translates missing or undefined inputs to a default value.
- **Encoding:** Input `a: A` transforms back to `i: I`

**Optional with Exactness**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true, default: () => A })`

- **Decoding:** Applies the default value only if the input is missing.
- **Encoding:** Input `a: A` transforms back to `i: I`

**Optional with Nullability**

`Schema.optionalWith(schema: Schema<A, I, R>, { nullable: true, default: () => A })`

- **Decoding:** Treats null, undefined, or missing inputs as defaults.
- **Encoding:** Input `a: A` transforms back to `i: I`

**Combining Exactness and Nullability**

`Schema.optionalWith(schema: Schema<A, I, R>, { exact: true, nullable: true, default: () => A })`

- **Decoding:** Defaults are applied when values are null or missing.
- **Encoding:** Input `a: A` transforms back to `i: I`

### Optional Fields as Options

**Basic Optional with Option Type**

`optionalWith(schema: Schema<A, I, R>, { as: "Option" })`

- **Decoding:**
  - Missing values or `undefined` are converted to `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a: A)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

**Optional with Exactness**

`optionalWith(schema: Schema<A, I, R>, { exact: true, as: "Option" })`

- **Decoding:**
  - Only truly missing values are converted to `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

**Optional with Nullability**

`optionalWith(schema: Schema<A, I, R>, { nullable: true, as: "Option" })`

- **Decoding:**
  - Treats missing, `undefined`, and `null` values all as `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a: A)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

**Combining Exactness and Nullability**

`optionalWith(schema: Schema<A, I, R>, { exact: true, nullable: true, as: "Option" })`

- **Decoding:**
  - Missing or `null` values lead to `Option.none()`.
  - Provided values (`i: I`) are converted to `Option.some(a: A)`.
- **Encoding:**
  - `Option.none()` results in the value being omitted.
  - `Option.some(a: A)` is converted back to the original input (`i: I`).

## Optional Fields Primitives

The `Schema.optional` and `Schema.optionalWith` functions are built on two foundational operations: `Schema.optionalToOptional` and `Schema.optionalToRequired`.
These functions provide nuanced control over how optional fields are handled in your schemas, allowing for precise property signatures.

### optionalToOptional

The `Schema.optionalToOptional` API is used to manage the transformation from an optional field to another optional field.
With this, we can control both the output type and the presence or absence of the field.

For example a common use case is to equate a specific value in the source field with the absence of value in the destination field.

Here's the signature of the `optionalToOptional` API:

```ts
export const optionalToOptional = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: Option.Option<FA>) => Option.Option<TI>,
    readonly encode: (o: Option.Option<TI>) => Option.Option<FA>
  }
): PropertySignature<"?:", TA, never, "?:", FI, false, FR | TR>
```

As you can see, we can transform the type by specifying a schema for `to`, which can be different from the schema of `from`.
Additionally, we can control the presence or absence of the field using `decode` and `encode`, with the following meanings:

- `Option.none()` as an argument means the value is missing in the input
- `Option.none()` as a return value means the value will be missing in the output

**Example**

Suppose we have an optional field of type `string`, and we want to exclude empty strings from the output. In other words, if the input contains an empty string, we want the field to be absent in the output.

```ts twoslash
import { Schema } from "@effect/schema"
import { identity, Option } from "effect"

const schema = Schema.Struct({
  a: Schema.optionalToOptional(Schema.String, Schema.String, {
    decode: (input) => {
      if (Option.isNone(input)) {
        // If the field is absent in the input, returning `Option.none()` will make it absent in the output too
        return Option.none()
      }
      const value = input.value
      if (value === "") {
        // If the field is present in the input but is an empty string, returning `Option.none()` will make it absent in the output
        return Option.none()
      }
      // If the field is present in the input and is not an empty string, returning `Option.some` will make it present in the output
      return Option.some(value)
    },
    // Here in the encoding part, we can decide to handle things in the same way as in the decoding phase
    // or handle them differently. For example, we can leave everything unchanged and use the identity function
    encode: identity
  })
})

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({})) // Output: {}
console.log(decode({ a: "" })) // Output: {}
console.log(decode({ a: "a non-empty string" })) // Output: { a: 'a non-empty string' }

const encode = Schema.encodeSync(schema)

console.log(encode({})) // Output: {}
console.log(encode({ a: "" })) // Output: { a: '' }
console.log(encode({ a: "foo" })) // Output: { a: 'foo' }
```

### optionalToRequired

The `Schema.optionalToRequired` API allows us to transform an optional field into a required one, applying custom logic if the field is absent in the input.

```ts
export const optionalToRequired = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: Option.Option<FA>) => TI,
    readonly encode: (ti: TI) => Option.Option<FA>
  }
): PropertySignature<":", TA, never, "?:", FI, false, FR | TR>
```

We can control the presence or absence of the field using `decode` and `encode`, with the following meanings:

- `Option.none()` as an argument means the value is missing in the input
- `Option.none()` as a return value means the value will be missing in the output

**Example**

For instance, a common use case is to assign a default value to the field in the output if it's missing in the input.

```ts twoslash
import { Schema } from "@effect/schema"
import { Option } from "effect"

const schema = Schema.Struct({
  a: Schema.optionalToRequired(Schema.String, Schema.String, {
    decode: (input) => {
      if (Option.isNone(input)) {
        // If the field is absent in the input, we can return the default value for the field in the output
        return "default value"
      }
      // If the field is present in the input, return its value as it is in the output
      return input.value
    },
    // During encoding, we can choose to handle things differently, or simply return the same value present in the input for the output
    encode: (a) => Option.some(a)
  })
})

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({})) // Output: { a: 'default value' }
console.log(decode({ a: "foo" })) // Output: { a: 'foo' }

const encode = Schema.encodeSync(schema)

console.log(encode({ a: "foo" })) // Output: { a: 'foo' }
```

### requiredToOptional

This API allows developers to specify how a field that is normally required can be treated as optional based on custom logic.

```ts
export const requiredToOptional = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (fa: FA) => Option.Option<TI>
    readonly encode: (o: Option.Option<TI>) => FA
  }
): PropertySignature<"?:", TA, never, ":", FI, false, FR | TR>
```

We can control the presence or absence of the field using `decode` and `encode`, with the following meanings:

- `Option.none()` as an argument means the value is missing in the input
- `Option.none()` as a return value means the value will be missing in the output

**Example**

Let's look at a practical example where a field `name` that is typically required can be considered optional if it's an empty string during decoding, and ensure there is always a value during encoding by providing a default.

```ts twoslash
import { Schema } from "@effect/schema"
import { Option } from "effect"

const schema = Schema.Struct({
  name: Schema.requiredToOptional(Schema.String, Schema.String, {
    decode: Option.liftPredicate((s) => s !== ""), // empty string is considered as absent
    encode: Option.getOrElse(() => "")
  })
})

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({ name: "John" })) // Output: { name: 'John' }
console.log(decode({ name: "" })) // Output: {}

const encode = Schema.encodeSync(schema)

console.log(encode({ name: "John" })) // { name: 'John' }
console.log(encode({})) // Output: { name: '' }
```

## Extending Schemas

### Spreading Struct fields

Structs expose their fields through a `fields` property. This feature can be utilized to extend an existing struct with additional fields or to merge fields from another struct.

**Example** (Adding Fields)

```ts twoslash
import { Schema } from "@effect/schema"

const Struct1 = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

const Extended = Schema.Struct({
  ...Struct1.fields,
  // other fields
  c: Schema.String,
  d: Schema.String
})
```

**Example** (Integrating Additional Index Signatures)

```ts twoslash
import { Schema } from "@effect/schema"

const Struct = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

const Extended = Schema.Struct(
  Struct.fields,
  Schema.Record({ key: Schema.String, value: Schema.String })
)
```

**Example** (Merging Fields from Two Structs)

```ts twoslash
import { Schema } from "@effect/schema"

const Struct1 = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

const Struct2 = Schema.Struct({
  c: Schema.String,
  d: Schema.String
})

const Extended = Schema.Struct({
  ...Struct1.fields,
  ...Struct2.fields
})
```

### The extend combinator

The `Schema.extend` combinator offers a structured way to extend schemas, particularly useful when direct field spreading is insufficient—for instance, when you need to extend a struct with a union of structs.

<Aside type="caution" title="Extension Support Limitations">
  Note that not all extensions are supported, and their support depends on
  the nature of the involved schemas.
</Aside>

Possible extensions include:

- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema

**Example** (Extending a Struct with a Union of Structs)

```ts twoslash
import { Schema } from "@effect/schema"

const Struct = Schema.Struct({
  a: Schema.String
})

const UnionOfStructs = Schema.Union(
  Schema.Struct({ b: Schema.String }),
  Schema.Struct({ c: Schema.String })
)

const Extended = Schema.extend(Struct, UnionOfStructs)
```

This example shows an attempt to extend a struct with another struct where field names overlap, leading to an error:

```ts twoslash
import { Schema } from "@effect/schema"

const Struct = Schema.Struct({
  a: Schema.String
})

const OverlappingUnion = Schema.Union(
  Schema.Struct({ a: Schema.Number }), // duplicate key
  Schema.Struct({ d: Schema.String })
)

const Extended = Schema.extend(Struct, OverlappingUnion)
/*
throws:
Error: Unsupported schema or overlapping types
at path: ["a"]
details: cannot extend string with number
*/
```

**Example** (Extending a refinement of Schema.String with another refinement)

```ts twoslash
import { Schema } from "@effect/schema"

const Integer = Schema.Int.pipe(Schema.brand("Int"))
const Positive = Schema.Positive.pipe(Schema.brand("Positive"))

// Schema.Schema<number & Brand<"Positive"> & Brand<"Int">, number, never>
const PositiveInteger = Schema.asSchema(Schema.extend(Positive, Integer))

Schema.decodeUnknownSync(PositiveInteger)(-1)
/*
throws
ParseError: Int & Brand<"Int">
└─ From side refinement failure
  └─ Positive & Brand<"Positive">
      └─ Predicate refinement failure
        └─ Expected Positive & Brand<"Positive">, actual -1
*/

Schema.decodeUnknownSync(PositiveInteger)(1.1)
/*
throws
ParseError: Int & Brand<"Int">
└─ Predicate refinement failure
  └─ Expected Int & Brand<"Int">, actual 1.1
*/
```

## Renaming Properties

### Renaming a Property During Definition

To rename a property directly during schema creation, you can utilize the `Schema.fromKey` function. This function is particularly useful when you want to map properties from the input object to different names in the resulting schema object.

**Example** (Renaming a Required Property)

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  a: Schema.propertySignature(Schema.String).pipe(Schema.fromKey("c")),
  b: Schema.Number
})

console.log(Schema.decodeUnknownSync(schema)({ c: "c", b: 1 }))
// Output: { a: "c", b: 1 }
```

**Example** (Renaming an Optional Property)

```ts twoslash
import { Schema } from "@effect/schema"

const schema = Schema.Struct({
  a: Schema.optional(Schema.String).pipe(Schema.fromKey("c")),
  b: Schema.Number
})

console.log(Schema.decodeUnknownSync(schema)({ c: "c", b: 1 }))
// Output: { b: 1, a: "c" }

console.log(Schema.decodeUnknownSync(schema)({ b: 1 }))
// Output: { b: 1 }
```

Note that `Schema.optional` returns a `PropertySignature`, which simplifies the process by eliminating the need for explicit `Schema.propertySignature` usage as required in the previous example.

### Renaming Properties of an Existing Schema

For existing schemas, the `rename` API offers a way to systematically change property names across a schema, even within complex structures like unions.

**Example** (Renaming Properties in a Struct Schema)

```ts twoslash
import { Schema } from "@effect/schema"

// Original Schema
const originalSchema = Schema.Struct({
  c: Schema.String,
  b: Schema.Number
})

// Renaming the "c" property to "a"
const renamedSchema = Schema.rename(originalSchema, { c: "a" })

console.log(Schema.decodeUnknownSync(renamedSchema)({ c: "c", b: 1 }))
// Output: { a: "c", b: 1 }
```

**Example** (Renaming Properties in Union Schemas)

```ts twoslash
import { Schema } from "@effect/schema"

const originalSchema = Schema.Union(
  Schema.Struct({
    c: Schema.String,
    b: Schema.Number
  }),
  Schema.Struct({
    c: Schema.String,
    d: Schema.Boolean
  })
)

// Renaming the "c" property to "a" for all members
const renamedSchema = Schema.rename(originalSchema, { c: "a" })

console.log(Schema.decodeUnknownSync(renamedSchema)({ c: "c", b: 1 }))
// Output: { a: "c", b: 1 }

console.log(Schema.decodeUnknownSync(renamedSchema)({ c: "c", d: false }))
// Output: { d: false, a: 'c' }
```

## Recursive Schemas

The `Schema.suspend` function is useful when you need to define a schema that depends on itself, like in the case of recursive data structures.

**Example**

In this example, the `Category` schema depends on itself because it has a field `subcategories` that is an array of `Category` objects.

```ts twoslash
import { Schema } from "@effect/schema"

interface Category {
  readonly name: string
  readonly subcategories: ReadonlyArray<Category>
}

const Category = Schema.Struct({
  name: Schema.String,
  subcategories: Schema.Array(
    Schema.suspend((): Schema.Schema<Category> => Category)
  )
})
```

<Aside type="note" title="Correct Inference">
  It is necessary to define the `Category` type and add an explicit type
  annotation because otherwise TypeScript would struggle to infer types
  correctly. Without this annotation, you might encounter the error
  message:
</Aside>

```ts twoslash
import { Schema } from "@effect/schema"

// @ts-expect-error
const Category = Schema.Struct({
  name: Schema.String,
  // @ts-expect-error
  subcategories: Schema.Array(Schema.suspend(() => Category))
})
/*
'Category' implicitly has type 'any' because it does not have a type annotation and is
referenced directly or indirectly in its own initializer.ts(7022)
*/
```

### A Helpful Pattern to Simplify Schema Definition

As we've observed, it's necessary to define an interface for the `Type` of the schema to enable recursive schema definition, which can complicate things and be quite tedious.
One pattern to mitigate this is to **separate the field responsible for recursion** from all other fields.

```ts twoslash
import { Schema } from "@effect/schema"

const fields = {
  name: Schema.String
  // ...possibly other fields
}

// Define an interface for the Category schema, extending the Type of the defined fields
interface Category extends Schema.Struct.Type<typeof fields> {
  // Define `subcategories` using recursion
  readonly subcategories: ReadonlyArray<Category>
}

const Category = Schema.Struct({
  ...fields, // Include the fields
  subcategories: Schema.Array(
    // Define `subcategories` using recursion
    Schema.suspend((): Schema.Schema<Category> => Category)
  )
})
```

### Mutually Recursive Schemas

Here's an example of two mutually recursive schemas, `Expression` and `Operation`, that represent a simple arithmetic expression tree.

```ts twoslash
import { Schema } from "@effect/schema"

interface Expression {
  readonly type: "expression"
  readonly value: number | Operation
}

interface Operation {
  readonly type: "operation"
  readonly operator: "+" | "-"
  readonly left: Expression
  readonly right: Expression
}

const Expression = Schema.Struct({
  type: Schema.Literal("expression"),
  value: Schema.Union(
    Schema.Number,
    Schema.suspend((): Schema.Schema<Operation> => Operation)
  )
})

const Operation = Schema.Struct({
  type: Schema.Literal("operation"),
  operator: Schema.Literal("+", "-"),
  left: Expression,
  right: Expression
})
```

### Recursive Types with Different Encoded and Type

Defining a recursive schema where the `Encoded` type differs from the `Type` type adds another layer of complexity. In such cases, we need to define two interfaces: one for the `Type` type, as seen previously, and another for the `Encoded` type.

**Example**

Let's consider an example: suppose we want to add an `id` field to the `Category` schema, where the schema for `id` is `NumberFromString`.
It's important to note that `NumberFromString` is a schema that transforms a string into a number, so the `Type` and `Encoded` types of `NumberFromString` differ, being `number` and `string` respectively.
When we add this field to the `Category` schema, TypeScript raises an error:

```ts twoslash
import { Schema } from "@effect/schema"

const fields = {
  id: Schema.NumberFromString,
  name: Schema.String
}

interface Category extends Schema.Struct.Type<typeof fields> {
  readonly subcategories: ReadonlyArray<Category>
}

const Category = Schema.Struct({
  ...fields,
  subcategories: Schema.Array(
    // @ts-expect-error
    Schema.suspend((): Schema.Schema<Category> => Category)
  )
})
/*
Type 'Struct<{ subcategories: Array$<suspend<Category, Category, never>>; id: typeof NumberFromString; name: typeof String$; }>' is not assignable to type 'Schema<Category, Category, never>'.
  The types of 'Encoded.id' are incompatible between these types.
    Type 'string' is not assignable to type 'number'.ts(2322)
*/
```

This error occurs because the explicit annotation `Schema.Schema<Category>` is no longer sufficient and needs to be adjusted by explicitly adding the `Encoded` type:

```ts twoslash
import { Schema } from "@effect/schema"

const fields = {
  id: Schema.NumberFromString,
  name: Schema.String
}

interface Category extends Schema.Struct.Type<typeof fields> {
  readonly subcategories: ReadonlyArray<Category>
}

interface CategoryEncoded extends Schema.Struct.Encoded<typeof fields> {
  readonly subcategories: ReadonlyArray<CategoryEncoded>
}

const Category = Schema.Struct({
  ...fields,
  subcategories: Schema.Array(
    Schema.suspend(
      (): Schema.Schema<Category, CategoryEncoded> => Category
    )
  )
})
```
